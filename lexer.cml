(* =========================================================================
 * cakedep: resolve cakeml include pragmas
 *
 * Oskar Abrahamsson, 2021                                    www.cakeml.org
 * ========================================================================= *)

exception Fail string;

fun fail () = raise Fail "";

fun failwith msg = raise Fail msg;

fun str_hash str =
  let
    fun hash acc i =
      if i >= String.size str then acc else
        hash (13 * acc + Char.ord (String.sub str i)) (i + 1)
  in
    hash 0 0
  end;

(* -------------------------------------------------------------------------
 * A valid pragma should match this regex (I think):
 *   ^@include\('[^']*'\)\w*$
 *
 * - It should start at the beginning of the line
 * - It continues until the end of the line (any amount of trailing spaces
 *   until EOL is ok)
 * - Any non-tick symbol can go between the ticks, but it should only be
 *   something that can be interpreted as a filename
 * ------------------------------------------------------------------------- *)

fun dest_include str =
  case String.fields (fn x => x = #"'") str of
    [pre, file, post] =>
      if pre = "@include(" andalso
         String.sub post 0 = #")" andalso
         List.all Char.isSpace (List.drop (String.explode post) 1)
      then Some file
      else None
  | _ => None;

val is_include = Option.isSome o dest_include;

(* -------------------------------------------------------------------------
 * Read all lines from a file, and collect all includes.
 * - All pragmas are expected to go at the very top, before anything else.
 *   Once we see something which is not a pragma, we stop reading the file.
 * We return the file path(s) found in the pragma(s), together with the rest
 * of the input file (i.e. post-pragma).
 *   ^@include\('[^']*'\)\w*$
 *
 * In other words, this is OK:
 *
 *   01  @include('foo/bar.cml')
 *   02  @include('baz.cml')
 *   03 <other stuff here>
 *
 * And this is not OK:
 *
 *   01
 *   02  @include('foo/bar.cml')
 *   03  @include('baz.cml')
 *   04  <other stuff>
 * ------------------------------------------------------------------------- *)

val dest_includes =
  let
    fun dest_includes' files l =
      case l of
        [] => (files, String.concat l)
      | h::t =>
          case dest_include h of
            None => (files, String.concat l)
          | Some f => dest_includes' (f::files) t;
  in
    dest_includes' []
  end;

fun read_includes fname =
  case TextIO.b_inputLinesFrom fname of
    None => failwith ("No such file: " ^ fname)
  | Some lines => dest_includes lines;

(*
val _ =
  case CommandLine.arguments () of
    ["--help"] =>
      (print "usage: ";
       print (CommandLine.name ());
       print " [(--help|filename)]";
       print "\n\n";
       print "OPTIONS:\n";
       print "  --help      show this text\n";
       print "\n";
       print "  If no options nor files are provided then some tests are run.";
       print "\n\n")
  | [file] =>
      let
        val (files, rest) = read_includes file
      in
        print "=== Includes: ===\n\n";
        List.mapi (fn i => fn s => print (" " ^ Int.toString i ^ ". " ^
                                          s ^ "\n")) files;
        print "\n";
        print "=== The rest (code): ===\n\n";
        print ("(* BEGIN: " ^ file ^ " *)\n");
        print rest;
        print ("\n(* END: " ^ file ^ " *)\n")
      end
      handle Fail err =>
        (print (CommandLine.name ());
         print " failed: ";
         print err;
         print "\n")
  | _ =>
    let
      val test1 = "@include('../foo/bar.cml')           "
      val test2 = "@include('../foo/bar.cml')           \n"
      val test3 = "@include('../foo/bar.cml')"
      val test4 = " @include('../foo/bar.cml')"
      val test5 = " @include(../foo/bar.cml')"
      val test6 = " @include('..''/foo/bar.cml')"
      val test7 = "@include('../foo/bar.cml')          k "
      fun do_test test =
        (print "  is_include \"";
         print test;
         print "\": ";
         print (if is_include test then "yes\n" else "no\n"))
    in
      print "=== Some tests: ===\n";
      do_test test1;
      do_test test2;
      do_test test3;
      do_test test4;
      do_test test5;
      do_test test6;
      do_test test7
    end;
    *)

(* -------------------------------------------------------------------------
 * Sets-as-lists.
 * ------------------------------------------------------------------------- *)

structure Set = struct
  local
    datatype 'a set = Set ('a list);
    fun mem_ x = List.exists (fn y => x = y);
    fun insert_ x xs = if mem_ x xs then xs else x::xs;
    fun del x xs =
      case xs of
        [] => xs
      | y::ys => if x = y then ys else y::del x ys;
    fun delete_ x xs = if mem_ x xs then del x xs else xs;
    fun nub_ xs =
      case xs of
        [] => xs
      | y::ys => if mem_ y ys then nub_ ys else y::nub_ ys;
  in
    type 'a set = 'a set;
    fun mem x s = case s of Set xs => mem_ x xs;
    fun insert x s = Set (case s of Set xs => insert_ x xs);
    fun delete x s = Set (case s of Set xs => delete_ x xs);
    val empty = Set [];
    fun fromList xs = Set (nub_ xs);
    fun toList (Set xs) = xs;
    fun exists p (Set xs) = List.exists p xs;
  end (* local *)
end (* struct *)

(* -------------------------------------------------------------------------
 * Dependencies are stored in a graph represented as a hashmap from string
 * keys to 'entry' pairs.
 * ------------------------------------------------------------------------- *)

structure DepGraph = struct

  type entry = string *        (* file contents (code)    *)
               string Set.set; (* children (dependencies) *)

  local
    type graph = (string, entry) Hashtable.hashtable;

    (* The dependency-graph is populated by a call to [build].
     *)
    val the_dep_graph: graph =
      Hashtable.empty 10 str_hash String.compare;

    (* [build] builds the dependency graph [the_dep_graph].
     *)
    fun build visited worklist =
      case worklist of
        [] => ()
      | fname::rest =>
          if Set.mem fname visited then
            build visited rest
          else
            let
              val (depfiles, code) = read_includes fname
              val visited = Set.insert fname visited
              val deps = Set.fromList depfiles
              val _ = Hashtable.insert the_dep_graph fname (code, deps)
            in
              build visited (depfiles @ rest)
            end;

    (* [cyclic] checks the dependency graph for cycles using a simple depth-first
     * search.
     *)
    fun cyclic visited fname =
      if Set.mem fname visited then True else
        case Hashtable.lookup the_dep_graph fname of
          None => False
        | Some (_, deps) => Set.exists (cyclic (Set.insert fname visited)) deps;

    datatype mark = Temp | Perm;

    (* The mark set keeps track of marks for nodes during the topological order
     * computation [toporder].
     *)
    val the_mark_set: (string, mark) Hashtable.hashtable =
      Hashtable.empty 10 str_hash String.compare;

    (* Some topological ordering algorithm off Wikipedia. Apparently the original
     * source is a textbook: Cormen et al., (2001), "Section 22.4: Topological
     * sort", Introduction to Algorithms (2nd ed.), MIT Press and McGraw-Hill,
     * pp. 549â€“552, ISBN 0-262-03293-7.
     *
     * Invariant: unmarked nodes are stored in worklist because they're easier to
     * access that way. When they get marked, their mark is stored in
     * [the_mark_set].
     *)
    fun toporder order worklist =
      case worklist of
        [] => List.rev order
      | node::rest => toporder (visit order node) rest
    and visit order node =
      case Hashtable.lookup the_mark_set node of
        Some Perm => order
      | Some Temp => failwith "visit: graph is not acyclic!"
      | None =>
          let
            val _ = Hashtable.insert the_mark_set node Temp
            val (_, deps) = Option.valOf (Hashtable.lookup the_dep_graph node)
                            handle Bind =>
                              failwith ("node " ^ node ^ " is missing from the " ^
                                        "dependency graph")
            val deplist = Set.toList deps
            val order' = List.foldl visit order deplist
            val _ = Hashtable.insert the_mark_set node Perm
          in
            node::order
          end;
  in
    val toporder = fn start => toporder [] [start];

    fun reset () =
      (Hashtable.clear the_dep_graph;
       Hashtable.clear the_mark_set);

    val build = fn start => build Set.empty [start];

    val cyclic = cyclic Set.empty;

    fun dump () = Hashtable.toAscList the_dep_graph;
  end (* local *)
end (* struct *)

(* -------------------------------------------------------------------------
 * The function [compute_deps] takes a filename, transitively computes the
 * dependencies of this file, and generates a topological order together with
 * a concatenated string that represent the contents (code) of those files,
 * presented in the topological order.
 * ------------------------------------------------------------------------- *)

fun compute_deps fname =
  let
    val _ = DepGraph.build fname
    val _ = DepGraph.cyclic fname orelse
            failwith "Dependency graph contains a cycle"
    val order = DepGraph.toporder fname
    val depgraph = DepGraph.dump ()
    val _ = print "=== TOPOLOGICAL ORDERING: ===\n";
    val _ = List.mapi (fn i => fn s =>
                         (print (Int.toString i);
                          print ". "; print s; print "\n"))
                      order
    val _ = print "\n"
    val code =
      String.concat (List.map (fst o Option.valOf o Alist.lookup depgraph)
                               order)
  in
    (code, order)
  end;

(* -------------------------------------------------------------------------
 * Entrypoint.
 * ------------------------------------------------------------------------- *)

val usage =
  String.concat [
    "cakedep: thing for resolving dependencies in CakeML projects\n",
    "Usage: ", CommandLine.name (), " [options] <filename>\n",
    "\n",
    "OPTIONS:\n",
    "\n",
    "    -h, --help         Show this message\n",
    "\n"
  ];

val _ =
  case CommandLine.arguments () of
    "-h"::_ => print usage
  | "--help"::_ => print usage
  | [file] =>
       (let
          val (code, order) = compute_deps file
          val ostream = TextIO.openOut "output.cml"
          val _ = TextIO.output ostream code
          val _ = TextIO.closeOut ostream
        in
          print "Wrote to \"output.cml\". Bye!\n"
        end
        handle Fail err =>
          (print (CommandLine.name ());
           print " failed with this error:\n   ";
           print err;
           print "\n"))
  | opts =>
      (print "Unknown options: ";
       List.app (fn s => print (s ^ " ")) opts;
       print "...\n\n";
       print usage);

(* vim: ft=sml
 *)
